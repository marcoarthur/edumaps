use Mojo::Base -strict, -signatures;
use Rex -feature => [qw( 1.4 exec_autodie) ];
use Rex::Commands::Rsync;
binmode STDOUT, ':encoding(UTF-8)';   # ou ':utf8'
binmode STDERR, ':encoding(UTF-8)';

user 'root';
key_auth;
my $app_dir = "/opt/map_app";
my $frontend_dir = "$app_dir/frontend/map_app";

sub info(@args) { Rex::Logger::info(@args) };

desc "Deploy aplicaÃ§Ã£o GIS para container LXC";
task "deploy", 
sub {

  # 1. Instalar dependÃªncias do sistema
  install_system_dependencies();

  # 2. Sincronizar arquivos via Rex::Commands::Rsync
  LOCAL {
    my $server = Rex::get_current_connection()->{server};
    my $args = [ 
      qw{ 
        -rl 
        --stats 
        --verbose 
        --exclude=*.swp 
        --exclude=*.tmp 
        --exclude=.git* 
        --exclude=*.conf
        --exclude=dist/*
        --exclude=.vscode*
        --exclude=node_modules/*
        --recursive --links --verbose --stats --backup --perms 
        .
      }, "$server:$app_dir" 
    ];
    info "ðŸ”„ Sincronizando arquivos da aplicaÃ§Ã£o...";
    run 'rsync', $args, auto_die => TRUE;
  };

  # 3. Instalar dependÃªncias Perl
  install_perl_dependencies();
  #
  # # 5. Configurar frontend
  # setup_frontend($frontend_dir);
  #
  # # 6. Configurar serviÃ§os
  # setup_services($app_dir);
  #
  # say "âœ… Deploy concluÃ­do com sucesso!";
};

sub install_system_dependencies() {
  info "ðŸ“¦ Instalando dependÃªncias do sistema...";

  update_package_db;

  # Instalar pacotes essenciais 
  my @packages = qw(
    rsync
    build-essential
    curl
  );

  pkg $_, ensure => "present" for @packages;
}

sub install_perl_dependencies() {
  info "ðŸ« Instalando dependÃªncias Perl...";

  # Instalar cpanminus se nÃ£o existir
  if (!is_installed("cpanm")) {
    say "Instalando cpanminus...";
    run "curl -L https://cpanmin.us | perl - App::cpanminus";
    run "cpanm App::cpm";
  }

  # Instalar mÃ³dulos Perl necessÃ¡rios (apenas se nÃ£o estiverem instalados)
  my @modules = qw(
    Carton
  );

  for my $module (@modules) {
    say "ðŸ“¥ Instalando mÃ³dulo Perl: $module";
    run "cpm install -g $module";
    say "âœ… MÃ³dulo $module instalado";
  }
  
  info("ðŸ« Instalando dependencias para map_app.pl");
  run "carton install", cwd => $app_dir;
}

sub setup_frontend($frontend_dir) {
  info "ðŸŽ¨ Configurando frontend Svelte...";

  if (is_file("package.json") && (!is_dir("node_modules") || needs_npm_install($frontend_dir))) {
    say "ðŸ“¦ Instalando dependÃªncias Node.js...";
    run "npm install";
  }

  # Build da aplicaÃ§Ã£o Svelte (apenas se necessÃ¡rio)
  if (!is_dir("$frontend_dir/dist") || needs_build($frontend_dir)) {
    say "ðŸ—ï¸  Executando build do frontend...";
    run "npm run build";
  } else {
    say "âœ… Frontend jÃ¡ estÃ¡ construÃ­do";
  }
}

sub setup_services($app_dir) {
  say "ðŸ”§ Configurando serviÃ§os...";

  # Criar arquivo de serviÃ§o systemd
  file "/etc/systemd/system/sp_municipalities.service",
  content => template('@service_unit',
    app_dir => $app_dir,
    user => "root"
  ),
  on_change => sub {
    say "ðŸ”„ Recarregando systemd...";
    run "systemctl daemon-reload";
  };

  # Habilitar e iniciar serviÃ§o
  service "sp_municipalities", ensure => "started";
  service "sp_municipalities", enable => TRUE;
}

# FunÃ§Ãµes auxiliares para verificar necessidade de rebuild
sub needs_npm_install($frontend_dir) {
  my $local_pkg = "./frontend/map_app/package.json";
  my $remote_pkg = "$frontend_dir/package.json";

  if (!is_file($remote_pkg)) {
    return 1;
  }

  # ComparaÃ§Ã£o simples - em produÃ§Ã£o usar checksum
  my $local_mtime = (stat($local_pkg))[9];
  my $remote_mtime = run "stat -c %Y $remote_pkg";

  return $local_mtime > $remote_mtime;
}

sub needs_build($frontend_dir) {
  my $dist_dir = "$frontend_dir/dist";

  if (!is_dir($dist_dir)) {
    return 1;
  }

  # Verificar se os arquivos fonte sÃ£o mais recentes que o build
  my $src_mtime = run "find $frontend_dir/src -name '*.svelte' -exec stat -c %Y {} \\; | sort -n | tail -1";
  my $dist_mtime = run "find $dist_dir -name '*.js' -exec stat -c %Y {} \\; | sort -n | tail -1";

  return $src_mtime > $dist_mtime;
}

desc "Verificar status da aplicaÃ§Ã£o";
task "status", group => "lxc_containers", sub {
  service "sp_municipalities", status => TRUE;
  run "systemctl status sp_municipalities";
};

desc "Parar aplicaÃ§Ã£o";
task "stop", group => "lxc_containers", sub {
  service "sp_municipalities", ensure => "stopped";
};

desc "Reiniciar aplicaÃ§Ã£o";
task "restart", group => "lxc_containers", sub {
  service "sp_municipalities", ensure => "restarted";
};

__DATA__
@service_unit
[Unit]
Description=SP Municipalities GIS Application
After=network.target postgresql.service
Requires=postgresql.service

[Service]
Type=simple
User=<%= $user %>
WorkingDirectory=<%= $app_dir %>
ExecStart=/usr/bin/perl <%= $app_dir %>/script/sp_municipalities daemon -l http://*:3000
Restart=always
RestartSec=5
Environment=MOJO_MODE=production

[Install]
WantedBy=multi-user.target
